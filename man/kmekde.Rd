% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kmekde.R
\name{kmekde}
\alias{kmekde}
\title{Fits AFT Semiparametric Mixture Cure Model using the KME-KDE method}
\usage{
kmekde(
  time,
  event,
  survPreds,
  curePreds = NULL,
  multiOptim_maxit = 1,
  multiOptim_reltol = 0.001,
  multiOptim_stopTime = NULL,
  multiOptim_stopLLp = 0,
  reltolOptim = 1e-08,
  maxitOptim = 500,
  silent = FALSE,
  shooting = FALSE,
  reltolShoot = 1e-08,
  maxitShoot = 250,
  reltolShoot_beta = 1e-08,
  maxitShoot_beta = 500,
  reltolShoot_gamma = 1e-05,
  maxitShoot_gamma = 50,
  fix_gammacoef = NULL,
  fix_betacoef = NULL,
  bandcoef = 1,
  try_hessian = FALSE,
  optim_method = "Nelder-Mead",
  optim_init = NULL
)
}
\arguments{
\item{time}{is the observed time to event variable}

\item{event}{is the status variable: 1 for event and 0 for censoring}

\item{survPreds}{is the matrix of survival predictor variable(s)}

\item{curePreds}{is the (optional) matrix of curing predictor variable(s)}

\item{multiOptim_maxit}{is the maximum of allowed multi-optimization. Suggestion: increase this number especially in the case of multiple predictors}

\item{multiOptim_reltol}{is the relative tolerance in continuing multi-optimization}

\item{multiOptim_stopTime}{is an optional time limit to stop multi-optimization based on calculation time per minutes}

\item{multiOptim_stopLLp}{is an extra option for stopping multi-optimization based on the proportion of log-likelihood successive changes in multi-optimization. It is a value between 0 to 1 where for example, 0 disable this stopping rule, and 0.1 stop multi-optimization when the difference in the latest loglik runs becomes less or equal to 0.1 of difference between loglik values in the first and second "optim" runs.}

\item{reltolOptim}{is the relative tolerance in continuing of each optimization run}

\item{maxitOptim}{is the maximum of allowed iterations in each optimization run}

\item{silent}{a Boolean value which if set to TRUE it prevent from showing output messages}

\item{shooting}{a Boolean value which if it is set to TRUE it uses a shooting method (coordinate descent) instead of the usual gradient descent algorithm to find the optimum of Gamma and Beta coefficients conditionally on the estimate of the other one.}

\item{reltolShoot}{is the relative tolerance in continuing the shooting algorithm optimization}

\item{maxitShoot}{is the maximum of allowed iterations in the shooting algorithm optimization}

\item{reltolShoot_beta}{is the relative tolerance in continuing optimization of the beta part in the shooting algorithm}

\item{maxitShoot_beta}{is the maximum of allowed iterations in the optimization of the beta part in the shooting algorithm}

\item{reltolShoot_gamma}{is the relative tolerance in continuing optimization of the gamma part in the shooting algorithm}

\item{maxitShoot_gamma}{is the maximum of allowed iterations in the optimization of the gamma part in the shooting algorithm}

\item{fix_gammacoef}{is an optional vector of fix gamma coefficients that could be used to estimate beta coefficients based of them. This can be used for conditional optimization.}

\item{fix_betacoef}{is an optional vector of fix beta coefficients that could be used to estimate gamma coefficients based of them. This can be used for conditional optimization.}

\item{bandcoef}{is an optional coefficient to multiply the optimal kernel smoothing band-width (Please note the loglik values resulted by applying different "bandcoef" are not comparable. So, changing the default value of this option is Not recommended.)}

\item{try_hessian}{is a Boolean with default value of FALSE. If this set to TRUE, the Hessian matrix will be evaluated after last optimization by applying a final optimization that also try to estimate the hessian matrix}

\item{optim_method}{is the method of optimization: "Nelder-Mead" and "SANN" are supported}

\item{optim_init}{is an optional vector of initial values to be used in continuing optimization of previously estimated coefficients by optionally providing them as initial values.}
}
\value{
a list of "exitcode" (0: no warning or error, 1: warning, 2 or 3: error), "coef" (estimated coefficients), "AIC", etc. check names(fit) for more information.
}
\description{
Fits AFT (Accelerated Failure Time) Semiparametric Mixture Cure Model using the KME-KDE (Kaplan-Meier Estimation and Kernel Density Estimator) method.
}
\examples{
data(hfp)

fit1 = kmekde (time=hfp[,1], event=hfp[,2], survPreds=hfp[,-(1:2)], curePreds=hfp[,-(1:2)])

names(fit1)

if(fit1$exitcode==0){
print(fit1$loglik)
print(fit1$timeD)
# print(fit1$coef)
}

fit2 = kmekde (time=hfp[,1], event=hfp[,2], survPreds=hfp[,-(1:2)], curePreds=hfp[,-(1:2)],
               shooting=TRUE)
print(fit2$exitcode)
print(fit2$loglik)
print(fit2$timeD)
# print(fit2$coef)

fit3 = kmekde (time=hfp[,1], event=hfp[,2], survPreds=hfp[,-(1:2)], curePreds=hfp[,-(1:2)],
               multiOptim_maxit = 5)
print(fit3$exitcode)
print(fit3$loglik)
print(fit3$timeD)
# print(fit3$coef)

fit4 = kmekde (time=hfp[,1], event=hfp[,2], survPreds=hfp[,-(1:2)], curePreds=hfp[,-(1:2)],
               multiOptim_maxit = 5, optim_init = fit3$coef)
print(fit4$exitcode)
print(fit4$loglik)
print(fit4$timeD)
# print(fit4$coef)

# fit5 = kmekde (time=hfp[,1], event=hfp[,2], survPreds=hfp[,-(1:2)], curePreds=hfp[,-(1:2)],
#                multiOptim_maxit = 500, multiOptim_stopTime = 10) # limit run to 10 minutes
# print(fit5$exitcode)
# print(fit5$loglik)
# print(fit5$timeD)
# print(fit5$coef)

}
