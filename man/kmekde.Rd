% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kmekde.R
\name{kmekde}
\alias{kmekde}
\title{The computational function that is called by the "kmcure" function to fits AFT Semiparametric Mixture Cure Model using the KME-KDE method}
\usage{
kmekde(
  time,
  event,
  survPreds,
  curePreds = NULL,
  multiOptim_maxit = 1,
  multiOptim_reltol = 0.001,
  multiOptim_stopTime = NULL,
  multiOptim_stopLLp = 0,
  optim_reltol = 1e-08,
  optim_maxit = 500,
  silent = FALSE,
  conditional = FALSE,
  cond_reltol = 1e-08,
  cond_maxit = 250,
  cond_reltol_beta = 1e-08,
  cond_maxit_beta = 500,
  cond_reltol_gamma = 1e-05,
  cond_maxit_gamma = 50,
  fix_gammacoef = NULL,
  fix_betacoef = NULL,
  bandcoef = 1,
  try_hessian = FALSE,
  optim_method = "Nelder-Mead",
  optim_init = NULL
)
}
\arguments{
\item{time}{a survival time to event variable.}

\item{event}{a survival status variable: 1 for event and 0 for censoring.}

\item{survPreds}{a matrix of survival predictor variable(s).}

\item{curePreds}{an optional matrix of curing predictor variable(s).}

\item{multiOptim_maxit}{a number showing the maximum of allowed multiple optimization. The program uses multiple optimization if the convergence of "optim" does not meet.}

\item{multiOptim_reltol}{a number showing the relative tolerance in continuing multiple optimization procedure.}

\item{multiOptim_stopTime}{an optional number showing time limit per minutes to stop multi-optimization based on calculation time per minutes.}

\item{multiOptim_stopLLp}{an optional proportion defining a stopping rule based on changes in log-likelihood in successive multi-optimization. 0 disable this stopping rule, and 0.1 stop multi-optimization when the difference in the latest loglik runs becomes less than or equal to 0.1 of difference between loglik values in the first and second "optim" runs.}

\item{optim_reltol}{a number showing the relative tolerance in continuing of each optimization.}

\item{optim_maxit}{a number showing the maximum of allowed iterations in each optimization.}

\item{silent}{a Boolean value which if set to TRUE it prevent from showing output messages.}

\item{conditional}{a Boolean value which, if set to TRUE it uses an iterative procedure that estimate parameters survival and cure sub-models conditionally on the last estimation of the other one.}

\item{cond_reltol}{a number showing the relative tolerance in continuing the conditional algorithm optimization.}

\item{cond_maxit}{a number showing the maximum of allowed iterations in the conditional algorithm optimization.}

\item{cond_reltol_beta}{a number showing the relative tolerance in continuing optimization of the beta part in the conditional algorithm.}

\item{cond_maxit_beta}{a number showing the maximum of allowed iterations in the optimization of the beta part in the conditional algorithm.}

\item{cond_reltol_gamma}{a number showing the relative tolerance in continuing optimization of the gamma part in the conditional algorithm.}

\item{cond_maxit_gamma}{a number showing the maximum of allowed iterations in the optimization of the gamma part in the conditional algorithm.}

\item{fix_gammacoef}{an optional numeric vector of fix gamma coefficients that could be used to estimate beta coefficients based of them. This can be used for conditional optimization.}

\item{fix_betacoef}{an optional numeric vector of fix beta coefficients that could be used to estimate gamma coefficients based of them. This can be used for conditional optimization.}

\item{bandcoef}{an optional coefficient to multiply the optimal kernel smoothing band-width (Please note the loglik values resulted by applying different "bandcoef" are not comparable. So, changing the default value of this option is Not recommended).}

\item{try_hessian}{a Boolean value with default value of FALSE. If this set to TRUE, the Hessian matrix will be evaluated after last optimization by applying a final optimization that also try to estimate the hessian matrix.}

\item{optim_method}{a string value showing the method of optimization: "Nelder-Mead" and "SANN" are supported.}

\item{optim_init}{an optional numeric vector of initial values. For example, it could be the estimated coefficients of a previous fit to be used in continuing of optimization.}
}
\value{
a list of "exitcode" (0: no warning or error, 1: warning, 2 or 3: error), "coef" (estimated coefficients), "AIC", etc. check names(fit) for more information.
}
\description{
Fits AFT (Accelerated Failure Time) Semiparametric Mixture Cure Model using the KME-KDE (Kaplan-Meier Estimation and Kernel Density Estimator) method.
}
\examples{

data(hfp)

time = hfp$Time

event = hfp$Event

survPreds = hfp[, c(3:15)]
names(survPreds)

curePreds = hfp[, c(3:15)]
names(curePreds)

# fit1 = kmekde (time, event, survPreds, curePreds, multiOptim_maxit = 10)

# names(fit1)

# fit1$exitcode==TRUE # if TRUE the fit completed without any warning/error
# fit1$loglik # the loglik of the fitted model
# fit1$timeD # the calculation time
# fit1$coef # the estimated coefficients

}
